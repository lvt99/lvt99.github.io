---
layout:     post
title:      动态规划（1）——LeetCode 1937
subtitle:   动态规划杀我
date:       2021-07-21
author:     Lv Tian
header-img: img/dp1
catalog: true
mathjax: true
tags:
    - 编程
    - LeetCode
    - 动态规划
--- 

## 动态规划

自从上大学接触编程以来，自己学会了诸多算法与数据结构：二叉树、平衡树、AVL树、红黑树、Dijkstra算法、KMP算法...也许曾经的学习过程中，自己也曾遇到过理解的困难与困惑，但是最终都无一例外地获得了Aha Moment。然而，有一类问题至今是我编程中非常薄弱的一个模块，自己每次遇到这一类问题总会感到由衷的敬畏，然后在思考~~数十秒~~很长时间后观看题解，并且感叹题目的精妙、算法的神奇~~以及自己的弱智~~。这一类问题就是**dynamic programming**，中文翻译为~~随缘编程~~动态规划。

那么什么是**动态规划**呢？这一名词实际上是Richard Bellman在上世纪50年代提出的概念，是数学上的一种优化方法，它实际上是一个分解决策的过程，将一个复杂的问题以递归的形式分解成一系列小问题。举个例子，有时候我们需要做一连串的决策来尽可能地把一件事情做好，但是受限于人类的计算能力以及对世界的观察能力等客观因素，人们无法**一下子**获得这个最优决策。但是，给定一些限制条件，我们可以将这个决策**分解**成一步一步的小决策，把它们按照顺序连接起来，就构成了完整的最优决策。

如何给4岁的儿童讲清楚这件事情呢？我们考虑一个问题：
$$ 1+1+1+1+1+1+1+1 = ?$$
经过大约10秒左右的计算，小孩子可以给出答案是$8$，这个时候如果我问：**如果还有一个$+1$呢？** 大家一定会很快地告诉我，答案是9。这个简单的问题实际上就蕴含着动态规划的思想，我们并不需要一下子算出结果，而是可以基于已有的子问题的结果进行进一步的计算，从而高效地完成计算问题。通常情况下，DP问题都有一个状态转移方程，描述了通过子问题获得最终答案的过程。例如这个例子中，记$f[n]$为有$n$个$1$相加的结果，那么计算分解的过程可以形式化地表示为：
$$f[n] = f[n-1] + 1$$
这可能是最简单的动态规划问题之一，能够理解这个方程的意义，那么会为之后动态规划的提供不少启示。

## 中场休息

![](img/tuzi.png)

## LeetCode 1937
那么我们尝试做一下LeetCode第250场周赛的第三题，这道题很明显是一道动态规划的问题，题面描述如下：

### 题目描述

给你一个 `m x n` 的整数矩阵 `points` （下标从 `0` 开始）。一开始你的得分为 `0` ，你想最大化从矩阵中得到的分数。

你的得分方式为：**每一行** 中选取一个格子，选中坐标为 `(r, c)` 的格子会给你的总得分 **增加** `points[r][c]` 。

然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 `r` 和 `r + 1` （其中 `0 <= r < m - 1`），选中坐标为 `(r, c1)` 和 `(r + 1, c2)` 的格子，你的总得分 **减少** `abs(c1 - c2)` 。

请你返回你能得到的 **最大** 得分。

`abs(x)` 定义为：

如果 `x >= 0` ，那么值为 `x` 。
如果 `x < 0` ，那么值为 `-x` 。

### 示例

![](img/1937-input1.png)
```
输入：points = [[1,2,3],[1,5,1],[3,1,1]]
输出：9
解释：
蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。
你的总得分增加 3 + 5 + 3 = 11 。
但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。
你的最终得分为 11 - 2 = 9 。
```

### 题解

这道题说白了，最终取值跟两个事儿相关，第一个是选取的方格中的数值，第二个是相邻两行相隔的列数。因此我们可以很容易地得到**状态转移方程**：

$$f[i][j] = \max(f[i-1][j'] - |j-j'|) + points[i][j]$$

其中$f[i][j]$为从最上面一行开始取值，选取到第$i$行第$j$列时最大的得分，$j'$为上一行选取的行号，$points[i][j]$为第$i$行第$j$列的值。整个方程翻译成自然语言就是：我要取到第$i$行第$j$列时得分最大，那么这个得分是由这一行格子中的值、列距离惩罚项以及上一行最大的当前得分共同决定的，~~没说人话~~。那么这个等式翻译成代码进行执行，对于每一行的每个点都需要考虑上一行所有值，因此假设行为$M$，列为$N$，那么算法的时间复杂度为$O(MN^2)$，太慢了！那么这个可以优化吗？当然可以，关键在于$\vert j-j'\vert$。当 $j-j'\geq 0$时，也就是说上一行取的列在当前行的左侧（包括同一列），那么状态转移方程可以化为：

$$f[i][j] = \max(f[i-1][j'] +j') + points[i][j] - j$$

因此，$\max(f[i-1][j'] +j')$这一项中**只剩下了关于前一行的内容**，不再需要两行的$O(N^2)$级别的比较！因此转换成具体算法，就是对于这一行，**从左到右**遍历每一个元素，计算其左上方一行的最大的$\max(f[i-1][j'] +j')$（动态更新），然后加上$points[i][j] - j$这一仅与目前值有关的项。同理，对于另一半的情况，即$j-j'< 0$时，状态转移方程化为：

$$f[i][j] = \max(f[i-1][j'] -j') + points[i][j] + j$$

转换成具体算法，就是对于这一行，**从右到左**遍历每一个元素，计算其右方上一行的最大的$\max(f[i-1][j'] - j')$（动态更新），然后加上$points[i][j] + j$这一仅与目前值有关的项。两半的$f[i][j]$取最大值作为当前格子的DP值。最终在最后一行，所有格子中DP值最大的一个即为整个表格的最大分数。

由于每一行最多只需要遍历3次（一次用于计算，两次用于计算下一行），因此算法的时间复杂度优化为$O(MN)$，**大优化**！

## 感悟

太难了，好好学习吧少年qaq

另外，这个似乎跟图像中的seam carving很像，同样需要计算一个像素选取方式，说不定在数字图像处理领域中有点用处？（不连续的seam carving）